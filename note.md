* 基于SpringMVC实现gateway时，为了避免Controller层影响网关接口的逻辑，可以在filter层就开始拦截Request，然后判断是否需要执行网关的逻辑
* 了解一下WebFlux的RouterFunction
* 写一个RouterFunction，拦截请求，中转到对应的服务(ok)
* loadBalancer、服务节点过滤等操作需要链路化优化(ok)
* 集成注册中心(ok)
* 优化一下错误响应处理逻辑(暂时没什么想法，先跳过)
* 尝试使用WebHandler来实现路由入口，以及整套调用链路
* 思考一下有什么更加优雅的方式注册RouterFunction（编程式的），现在这种用Bean来声明RouterFunction的，总感觉使用起来不是很便利（把GatewayEntranceRouter挪到discovery包的代码中进行手动声明）

TODO
* 集成配置中心
* zstRegistry包中的异常名称需要更正一下
* 设计一套前后过滤器，提供数据过滤转换功能（比如路径重写之类的）
* 想一个方式来处理同一个项目内的模块化代码（比如这个网关项目里面的各类PreHandler的实现实现类）
* 测试以下现在处理响应体的方式会不会有问题
* 写一个HandlerMapping来拦截请求（因为/**在SimpleHandlerMapping中被使用了，所以没办法用这个来匹配路径）

WebHandler的ServerWebExchange提供了Request对象来读取请求数据，Response来向输出流写入数据
Spring Gateway使用了WebHandler来作为请求的入口，执行整套Gateway中的filter->router-postFilter的流程。
提前从配置文件中生成路由信息，在该WebHandler中执行路由逻辑

WebFlux的请求处理入口，可以看DispatcherHandler.handle方法，它本身也是作为一个WebHandler被web容器调用的

添加自定义的WebHandler到DispatcherHandler的处理链路的思路，大致是从Context中获取DispatcherHandler使用的HandlerMapping实现类对象，将自己的WebHandler注入到合适的实现类对象中
(这个方案目前不可行，因为在WebFlux中默认只会使用一个WebHandler，即DispatcherHandler。要覆盖掉它也可以，但是这种实现方式yysy也不够优雅)

翻翻WebFlux的代码，看它塞了什么RequestMapping或WebHandler到处理DispatcherHandler中，作为自己实现的示例（它加了一个自己的HandlerMapping实现类）

或者是SimpleUrlHandlerMapping（往SimpleUrlHandlerMapping的urlMap里面插入数据就可以实现代码方式的urlEndpoint注册了）(记得注册了url之后调用一次initApplicationContext)
WebFliter的话直接声明为Bean就可以被调用了


研究一下WebServerExchange中的request怎么转换为RouterFunction中的ServerRequest（前者没有拿PathVariable的方法）
ServerReqeust有默认实现类DefaultServerRequest，构造方法参数为ServerWebExchange和List<HttpMessageReader<?>> messageReaders), 
messageReaders来自ServerCodecConfigurer这个Bean的.getReaders方法

ServerRequest的pathVariable，读取的是exchange的attributes这个map中key=org.springframework.web.reactive.function.server.RouterFunctions.uriTemplateVariables对应的Map类型的value，从这里拿pathVariable
（目前看来，就算不经过ServerRequest的转换，ServerWebExchange里面还是会解析pathVariable的）

为什么SimpleUrlHandlerMapping用Autowire注入的时候，会提示NoBean，但是在ReadyEvent中，又可以从Context里面拿到，难不成它是手动注册的？
（好像确实没有手动注册SimpleUrlHandlerMapping类型的Bean，在WebFlux自带的配置类中，注册的Bean是HandlerMapping类而不是SimpleUrlHandlerMapping,
估计要用这个接口来注入Bean，然后找到instanceof SimpleUrlHandlerMapping的Bean才可以拿到了）

ServerResponse写数据到WebServerExchange的代码，可以从ServerResponseResultHandler开始看起